<?php
// SARK Helper class
// Developed by CoCo
// Copyright (C) 2012 CoCoSoFt
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
 
Class helper {
public $navRowDisplayMsg;
	
public function sysCommit() {

// ask the helper to run a regen for us.
    
    $rc = $this->request_syscmd ("/bin/sh /opt/sark/scripts/srkgenAst >/dev/null 2>&1");   
	
// run FOP gen if enabled

	$dbh = DB::getInstance();
	$res = $dbh->query("SELECT RUNFOP FROM globals where pkey = 'global'")->fetch(PDO::FETCH_ASSOC);
	$runfop = $res['RUNFOP'];
	$dbh = NULL;	
	if ($runfop == 'enabled') {
		$rc = $this->request_syscmd ("perl /opt/sark/scripts/op_buttons.pl >/dev/null 2>&1");
		$rc = $this->request_syscmd ("perl /opt/sark/scripts/name_op_buttons.pl >/dev/null 2>&1");	
	}

/*
 * take a snapshot
 */ 
	$rc = $this->request_syscmd ("/bin/sh /opt/sark/scripts/snap.sh");

/*
 * reload asterisk
 */
	$rc = $this->request_syscmd ("asterisk -rx 'reload'");
	
	return;
}

public function commitOn () {
//turn the commit lamp on
	$dbh = DB::getInstance();
	$res=$dbh->exec("UPDATE globals SET MYCOMMIT='YES' WHERE pkey='global'");
	return;
}
	
public function request_syscmd ($data) {

//establish connection to the daemon
 
	$fp = fsockopen( "127.0.0.1", 7601, $errno, $errdesc, 1)
		or die("Connection to 127.0.0.1:7601 failed"); 
	$ret = null;
// read the ack sent by server.
	$ack[] = fgets($fp, 8192);
    $this->logit(" request_syscmd sending -> $data", 5 );
	fputs($fp, "$data\n"); 
//	while( ! preg_match(' /EOT/ ',$ret)) { 
	while (1) {
		$ret .= fgets($fp, 8192);
		if ( ! preg_match(' /EOT/ ',$ret)) { 
			break;
		} 
	} 
	fclose($fp);
	return ($ret);

}

public function validEmail($email)
{
   $isValid = true;
   $atIndex = strrpos($email, "@");
   if (is_bool($atIndex) && !$atIndex)
   {
      $isValid = false;
   }
   else
   {
      $domain = substr($email, $atIndex+1);
      $local = substr($email, 0, $atIndex);
      $localLen = strlen($local);
      $domainLen = strlen($domain);
      if ($localLen < 1 || $localLen > 64)
      {
         // local part length exceeded
         $isValid = false;
      }
      else if ($domainLen < 1 || $domainLen > 255)
      {
         // domain part length exceeded
         $isValid = false;
      }
      else if ($local[0] == '.' || $local[$localLen-1] == '.')
      {
         // local part starts or ends with '.'
         $isValid = false;
      }
      else if (preg_match('/\\.\\./', $local))
      {
         // local part has two consecutive dots
         $isValid = false;
      }
      else if (!preg_match('/^[A-Za-z0-9\\-\\.]+$/', $domain))
      {
         // character not valid in domain part
         $isValid = false;
      }
      else if (preg_match('/\\.\\./', $domain))
      {
         // domain part has two consecutive dots
         $isValid = false;
      }
      else if (!preg_match('/^(\\\\.|[A-Za-z0-9!#%&`_=\\/$\'*+?^{}|~.-])+$/', str_replace("\\\\","",$local)))
      {
         // character not valid in local part unless 
         // local part is quoted
         if (!preg_match('/^"(\\\\"|[^"])+"$/',
             str_replace("\\\\","",$local)))
         {
            $isValid = false;
         }
      }
   }
   return $isValid;
}

public function setRouteClass($var) {

#
# This little sub returns a "routeclass" for the open/closed/outcome value you input
# The routeclass makes life a lot easier for the AGI when it has
# to route a call through the open/closed/outcome vectors
#
# 0  => value is "None" for an IVR menu selection
# 1  => value is a dialable internal number (extension or callgroup)
# 2  => value is an IVR name
# 3  => value is the default IVR
# 4  => value is a queue name
# 5  => value is DISA
# 6  => value is CALLBACK
# 7  => Not Used
# 8  => value is a sibling
# 9  => value is a trunk name
# 10 => value is a custom_app name
# 11 => value is a trunk group
# 20 => value is Retrieve Voicemail
# 21 => value is Leave Voicemail
#100 => value is Operator
#101 => value is Hangup
#

        if ($var == "None") {
        	return 0;
        }
        if (preg_match('/^\*\d{3,4}$/', $var)) {
        	return 1;
        }
        if (preg_match('/^\d{3,4}$/', $var)) {
        	return 1;
        }

        if ($var == "Default IVR") {
        	return 3;
        }
        if ($var == "DISA") {
        	return 5;
        }
        if ($var == "CALLBACK") {
        	return 6;
        }
        if ($var == "Retrieve Voicemail") {
        	return 20;
        }
        if ($var == "Leave Voicemail") {
        	return 21;
        }
        if ($var == "Operator") {
        	return 100;
        }
        if ($var == "Hangup") {
        	return 101;
        }
        $ret = 0;
        $dbh = DB::getInstance();
		$sql = $dbh->prepare("SELECT ln.pkey,cr.carriertype FROM lineio ln INNER JOIN carrier cr ON cr.pkey = ln.carrier WHERE ln.pkey = ?");
		$sql->execute(array($var));
		$res = $sql->fetch();
        if ( isset($res['pkey']) ) { 
			$dbh = NULL;
			if ($res['carriertype'] == 'group') {
				return 11;
            }
            else {
        		if (preg_match('/~/', $var)) {
               		return 8;
               	}
               	else {
               		return 9;
               	}
            }
        }
		$sql = $dbh->prepare("SELECT pkey FROM speed WHERE pkey = ?");
		$sql->execute(array($var));
		$res = $sql->fetch();        
        if ( isset($res['pkey']) ) {
			$dbh = NULL;
			return 1;
		}
 
		$sql = $dbh->prepare("SELECT pkey FROM Queue WHERE pkey = ?");
		$sql->execute(array($var));
		$res = $sql->fetch();         
        if ( isset($res['pkey']) ) {
			$dbh = NULL;
			return 4;
		}

		$sql = $dbh->prepare("SELECT pkey FROM ivrmenu WHERE pkey = ?");
		$sql->execute(array($var));
		$res = $sql->fetch();         
        if ( isset($res['pkey']) ) {
			$dbh = NULL;
			return 2;
		}
		
		$sql = $dbh->prepare("SELECT pkey FROM Appl WHERE pkey = ?");
		$sql->execute(array($var));
		$res = $sql->fetch();        
        if ( isset($res['pkey']) ) {
			$dbh = NULL;
			return 10;
		}		

		$dbh = NULL;
        return NULL;
}

public function displayRouteClass($var) {

#
# This little sub returns a "routeclass name" for the routeclass value you input
#
# 0  => value is "None" for an IVR menu selection
# 1  => value is a dialable internal number (extension or callgroup)
# 2  => value is an IVR name
# 3  => value is the default IVR
# 4  => value is a queue name
# 5  => value is DISA
# 6  => value is CALLBACK
# 7  => Not Used
# 8  => value is a sibling
# 9  => value is a trunk name
# 10 => value is a custom_app name
# 11 => value is a trunk group
# 20 => value is Retrieve Voicemail
# 21 => value is Leave Voicemail
#100 => value is Operator
#101 => value is Hangup
#
	switch ($var) {
		
		case 0:
			return "None";		
		case 1:
			$ret = $this->pkey; 

			if (isset ($this->pkey)) {
				$dbh = DB::getInstance();
				$sql = $dbh->prepare("SELECT pkey FROM speed WHERE pkey = ?");
				$sql->execute(array($this->pkey));
				$res = $sql->fetch();
				$dbh = NULL;
				if ( isset($res['pkey']) ) {
					$ret = "Callgrp " . $this->pkey;
				}
				else {
					$handle = fopen("/etc/asterisk/sark_meetme.conf", "r") or die('Could not read file!');
					$conferences = array();
					while (!feof($handle)) {
						$row = trim(fgets($handle));
						if (preg_match (" /^;/ ", $row)) {
							continue;
						}
						if (preg_match (" /^conf\s*=>\s*(\d{3,4})/ ",$row,$matches)) {
							$conferences[$matches[1]]=$matches[1];
						}		
					}
					if (array_key_exists($this->pkey, $conferences)) {
						$ret = "Conf " . $this->pkey;
					}
				}				
			}	 
			return $ret;
		case 2;
			return "IVR " . $this->pkey;
		case 3:
			return "defaultIVR";
		case 4:
			return "Queue " . $this->pkey;
		case 5:
			return "DISA ";
		case 6:
			return "CALLBACK ";
		case 7:
			return NULL;
		case 8:
			return "Sib " . $this->pkey;
		case 9: 
			return "Trunk " . $this->pkey;
		case 10:
			return "App " . $this->pkey;
		case 11:
			return "Group " . $this->pkey;
		case 20:
			return "Retrieve Voicemail ";
		case 21:
			return "Leave Voicemail ";
		case 100:
			return "Operator";
		case 101:
			return "Hangup";
		default:
			return NULL;
	}
}

public function loopcheck ($key, $out) {
/*
 * check for loops in call forward chains
 */
 	
	$dbh = DB::getInstance();
	$speed = array();
	array_push($speed, $key);
    $outs = explode(' ', $out);
    
    foreach ($outs as $target) {
        if ( $target == $key ) {
			return True;  // loop detected
        }
        $sql = $dbh->prepare("SELECT pkey,out FROM speed WHERE pkey = ?");
		$sql->execute(array($out));
		$res = $sql->fetch();
		if ( isset($res['pkey']) ) { 
			$speednum = $res['pkey'];
			foreach ($speed as $uplevel) {
				if ($uplevel == $speednum) {
					return True; //loop detected
				}
			}
			array_push($speed, $speednum);
		
			$tmps = explode (' ', $res['out']);
			foreach ($tmps as $L2) {
				array_push($outs, $L2);
			
			}	
		}
	}
	return False; // no loop detected
}

public function ret_localip () {
    $work = `/sbin/ifconfig eth0`;    
	if (preg_match(" /inet addr:*?([\d.]+)/",$work,$matches)) { 
	 		return $matches[1]; 	 		
 	}
	return -1;   
}

public function rets() {
	
	$flg=false; 
	if ($handle = opendir('/opt/sark/passwd')) {
		while (false !== ($entry = readdir($handle))) {
			if (preg_match( '/\.(\d+)$/',$entry,$matches)) {
				$flg =  $matches[1];
				break;
			}
		}
		closedir($handle);
	}  
	if (! $flg) {
        $flg = rand(100000,1000000);
		`/bin/touch /opt/sark/passwd/.$flg`;
	}
	return ($flg);
}


//
// don't use this subnet function - it is incorrect
//
public function ret_subnet () {
    $work = `/sbin/ifconfig eth0`;
        if (preg_match(" /inet addr:*?([\d\.]+)/",$work,$matches)) {
             $subnet = preg_replace ( '/\d+$/','0', $matches[1] );
             return $subnet;
        }
    return -1;
}

/*
 * not used as far as I can see
 */ 
public function ret_externip () {
    $work = `/usr/bin/wget -q  -O  - checkip.dyndns.org`;   
	if (preg_match(" /Current IP Address:*.([\d\.]+)/",$work,$matches)) { 
	 		return $matches[1]; 	 		
 	}
	return -1; 
}
/*
 *  not used as far as I can see
 */ 
public function ret_subnetmask () {
    $work = `/sbin/ifconfig eth0`;    
	if (preg_match(" /Mask:*?([\d\.]+)/",$work,$matches)) { 
	 		return $matches[1]; 	 		
 	}
	return -1;
}

public function ret_password ($length = 8) {
/*
 * generate a phone password
 */ 
    $password = "";
    $possible = "2346789bcdfghjkmnpqrtvwxyzBCDFGHJKLMNPQRTVWXYZ";
    $maxlength = strlen($possible);
    if ($length > $maxlength) {
      $length = $maxlength;
    }
    $i = 0; 
    while ($i < $length) { 
      $char = substr($possible, mt_rand(0, $maxlength-1), 1);       
      // have we already used this character in $password?
      if (!strstr($password, $char)) { 
        // no, so it's OK to add it onto the end of whatever we've already got...
        $password .= $char;
        // ... and increase the counter by one
        $i++;
      }

    }
    return $password;
}

public function check_pid()  {

   	if  (`/bin/ps -e | /bin/grep asterisk | /bin/grep -v grep`) {
   		return(true);
   	}

	return (false);
}


public function check_hapid() {
	if  (`/bin/ps -e | /bin/grep heartbeat | /bin/grep -v grep`) {
    	return(true);
    }
	return (false);
}

public function check_hapid_installed () {
    if  ( file_exists ("/usr/lib/heartbeat/heartbeat") ) {
    	return(true);
    }
	return (false);
}  

public function getNextFreeExt() {
/*
 *  find the next unused ext#
 */	
	
	$dbh = DB::getInstance();
	$res = $dbh->query("SELECT SIPIAXSTART FROM globals where pkey = 'global'")->fetch(PDO::FETCH_ASSOC);
	$pkey = $res['SIPIAXSTART'];
	$sql = $dbh->prepare("SELECT pkey FROM ipphone WHERE pkey = ?");
	$sql->execute(array($pkey));
	$res = $sql->fetch();	
	while ( isset($res['pkey']) ) {
		$pkey++;
		$res = $dbh->query("SELECT pkey FROM ipphone where pkey = '" . $pkey . "'")->fetch(PDO::FETCH_ASSOC);
	}
	return $pkey;
	
}

public function getTable($table, $sql='',$filter=true, $default=false) {
/*
 * general table getter - it is used to filter the rows a panel "sees" based upon the
 * user who is making the request. - In general a user is filtered according to the
 * cluster(tenant) which owns it.
 */ 
	$dbh = DB::getInstance();
		
	if ( $sql == '' ) {
		$sql = "SELECT * from $table";
	}

// only do next if we're on-line	
	if (!empty($_SESSION)) {			
		if ($_SESSION['user']['pkey'] != 'admin' && $filter) {	
			$usql = $dbh->prepare("SELECT cluster,selection FROM user where pkey = ?");
			$usql->execute(array($_SESSION['user']['pkey']));
			$res = $usql->fetch();		
			if 	(array_key_exists('cluster',$res) && $res['selection'] != 'all' ) {
				$sql .= " WHERE cluster = '" . $res['cluster'] . "'";
				if ($default) {
					$sql .= " OR cluster='default'";
				}
			}
		}
	}
	
	$res = $dbh->query($sql);    
	$return = $res->fetchAll(); 
	return $return;
}

public function createTuple($tab,$rec,$check=true) {
/*
 * general tuple create - takes a table name and a partial array and creates a row 
 * 
 */ 
	$dbh = DB::getInstance();
	$table = "default_" . $tab;	
/*
 * Check if the row already exists 
 */
	if ($check) {
		$sql = $dbh->prepare("SELECT pkey FROM $tab WHERE pkey = ?");
		$sql->execute(array($rec['pkey']));
		$res = $sql->fetch();		
		if ( isset($res['pkey']) ) { 
			return "Row ( " . $rec['pkey'] . " ) already exists!";
		}
	} 
	$ret = $this->getLc(); 
	if ($ret) {
		return "Extension limit exceeded";
	}
/*
 * get a default row for this table
 * careful with this function call - its a call to whatever is in the variable $table not to a 
 * function called "table".
 */ 

	$outbuf = $this->$table();
/*
 * add the given array to the default array
 */ 
	foreach ($rec as $key=>$value ) {
		$outbuf[$key] = $value;
	}

/*
 * build the sql arguments
 */
	$varg =  array();	//   array of the actual values
	$vnarg = null;		// 	 varable name arg (list of the comma separated variable names)
	$qarg = null;		// 	 varable name arg (list of comma separated query placeholders for prepare)
	
	foreach ($outbuf as $key=>$value) {
		if (!strlen($value) == 0) {
			array_push($varg, $value);
			$qarg .= "?,";
			$vnarg .= $key . ',';
		}
	}

/*
 * remove trailing commas
 */ 
	$vnarg = substr($vnarg, 0, -1);
	$qarg = substr($qarg, 0, -1);
/*
 * ready the insert
 */
	$sql = $dbh->prepare("INSERT INTO $tab ($vnarg) VALUES ($qarg)");
	

/*
 * do it
 */  
	$sql->execute($varg);
	$this->commitOn();
	$this->logit("I'm creating a new $tab",3 );
	return 'OK';
}

public function setTuple($tab,$rec,$modpkey=false) {

/*
 * general tuple setter - takes a table name and a partial array and updates a row 
 */
	$dbh = DB::getInstance();
/*
 *  check for pkey
 */ 
	if (!array_key_exists('pkey',$rec)) {
		return "Update failed - no pkey given!";
	}
	$pkey = $rec['pkey'];

/*
 * Check the row exists 
 */
	$sql = $dbh->prepare("SELECT pkey FROM $tab WHERE pkey = ?");
	$sql->execute(array($rec['pkey']));
	$res = $sql->fetch();	
	if ( ! isset($res['pkey']) ) { 
		return "Row (" . $pkey . " ) doesn't exist!";
	}  
/*
 * build the sql arguments
 */
	$varg =  array();	//   array of the actual values
	$vnarg = null;		// 	 varable name arg (list of the comma separated variable names)
	
	foreach ($rec as $key=>$value) {
// ignore key field unless explicitly changed 
		if ($key == 'pkey') {
			if ($modpkey != false) {
				$vnarg .= $key . "=?,";
				array_push($varg,$modpkey);  
			}				
		}
		else {
			$vnarg .= $key . "=?," ;
			array_push($varg,$value); 	
		}			
	}
/*
 * remove trailing commas
 */ 
	$vnarg = substr($vnarg, 0, -1);
/*
 * ready the update
 */
	array_push($varg,$pkey);
	$sql = $dbh->prepare("UPDATE $tab SET $vnarg WHERE pkey=?");
/*
 * do it
 */  
	$sql->execute($varg);
	$this->commitOn();
	$this->logit("I'm updating $tab",3 );
	return 'OK';
}	

public function delTuple($tab,$pkey) {
/*
 * general tuple delete - takes a table name and a key
 */
	$dbh = DB::getInstance();
/*
 *  check for pkey
 */ 
	if ( ! isset($pkey)) {
		return "Delete failed - no pkey given!";
	}	
/*
 * Check the row exists 
 */
	$sql = $dbh->prepare("SELECT pkey FROM $tab WHERE pkey = ?");
	$sql->execute(array($pkey));
	$res = $sql->fetch();	
	if ( ! isset($res['pkey']) ) { 
		return "Row (" . $pkey . " ) doesn't exist!";
	}  
 

 $sql = $dbh->prepare("DELETE FROM $tab WHERE pkey =?");
 $sql->execute(array($pkey));
 $this->commitOn();
 $this->logit("I'm deleting $tab key $pkey", 5 );
 return 'OK';

}



public function predDelTuple($tab,$srch,$val) {
/*
 * predicated tuple delete - takes a table name, search field and value 
 */
	$dbh = DB::getInstance();

 $sql = $dbh->prepare("DELETE FROM $tab WHERE $srch = ?");
 $sql->execute(array($val));
 
 return 'OK';

}

public function buildTupleArray($post,&$tuple,$custom=false,$stripslash=array()) {
/*
 * build the update $tuple array from $_POST (ignoring button fields etc.)
 */
	$ignore = array(
		"save_x" => True,
		"save_y" => True,
		"searchkey" => True,
		"update_x" => True,
		"update_y" => True,		
		"commit_x" => True,
		"commit_y" => True,
		"commitClick_x" => True,
		"commitClick_y" => True,
		"tabselect" => True,
		"oldpkey" => True,
		"latency" => True,
		"tabselect" => True
	);
	$dont_strip_tags = array(
		"provision" => True,
		"sipiaxfriend" => True,
		"extalert" => True,
		"speedalert" => True,
		"alertinfo" => True,
		"alert0" => True,
		"alert1" => True,		
		"alert2" => True,		
		"alert3" => True,		
		"alert4" => True,
		"alert5" => True,		
		"alert6" => True,		
		"alert7" => True,		
		"alert8" => True,
		"alert9" => True,		
		"alert10" => True,		
		"alert11" => True,
		"BOUNCEALERT" => True		
	);
/*
 * we don't strip_tags from the provision or friend variable because they 
 * often need to contain them 
 */
	if ($custom) {
		$ignore = array_merge($ignore,$custom);
	}	
	foreach ($post as $key=>$value) {
		if (array_key_exists($key,$ignore)) {
			continue;
		}
		if (array_key_exists($key,$dont_strip_tags)) {
			$tuple[$key] = $value;
		}
		else {
			$tuple[$key] = strip_tags($value);
		}
		if (array_key_exists($key,$stripslash)) {		
			$tuple[$key] = stripslashes($value);
		}
	} 
} 	

public function exec_SQL($dbh,$sql) {
	
	try {
		$this->logit("running SQL -> $sql", 8 );
		$audit = fopen("/opt/sark/db/srkaudit.log","a");
		fwrite($audit,date("M j H:i:s") . ": " . $sql . "\n");		
		$res=$dbh->prepare($sql);
		$res->execute();
	} 
	catch (PDOException $e) {
    	echo $e->getMessage();	
    }
}

private function setCluster(&$rec) {
	if ( $_SESSION['user']['pkey'] != 'admin' ) {	
		$dbh = DB::getInstance();
		$sql = $dbh->prepare("SELECT cluster FROM user WHERE pkey = ?");
		$sql->execute(array($_SESSION['user']['pkey']));
		$res = $sql->fetch();		
		if 	(array_key_exists('cluster',$res)) {
			$rec ['cluster'] = $res ['cluster'];
		}
	}
}

public function qDistro (&$distro=array()) {

	$distro['rhel'] = false;
	$distro['centos'] = false;
	$distro['sme'] = false;
	$distro['debian'] = false;
	$distro['pika'] = false;	
	$distro['soundroot'] = '/var/lib/';
	$distro['name'] = Null;
	 
	if (file_exists('/etc/redhat-release')) {
		$distro['rhel'] = true;
		if (`/bin/grep -i CentOS /etc/redhat-release` ) {
			$distro['centos'] = true;
			$distro['name'] = 'centos';
		}
		if (`/bin/grep -i SME /etc/redhat-release` ) {
			$distro['sme'] = true;
			$distro['name'] = 'smeserver';
		}		
	}		
	if (file_exists('/etc/debian_version')) {
		$distro['debian'] = true;
		$distro['soundroot'] = '/usr/share/';
		$distro['name'] = 'debian';
	}
	if ( `/bin/uname -r | /bin/grep pika` ) {
		$distro['pika'] = true;
		$distro['soundroot'] = '/var/lib/';
	}		
	return;
}

public function getLc() {
/*
 * getLc
 */
	$dbh = DB::getInstance();
	$count = $dbh->query('select count(*) from ipphone')->fetchColumn();
	$res = $dbh->query("SELECT LKEY FROM globals where pkey = 'global'")->fetch(PDO::FETCH_ASSOC);
	$lkey = $res['LKEY'];	
	if ($lkey) { 
		$retvar = checkLc($lkey);
		if ($retvar == 0) {
			if ($count >= $output[0]) {
				return 1;
			}
			return 0;
		}
	}
			
	$res = $dbh->query("SELECT EXTLIM FROM globals where pkey = 'global'")->fetch(PDO::FETCH_ASSOC);
	$extlim = $res['EXTLIM'];
	if (! $extlim) {
		return 0;
	}			
	if ($count >= $extlim) {
		return 1;
	} 		
	return 0;
}

private function checkLc($lkey) {

    $mac = strtoupper(`ip link show eth0 | awk '/ether/ {print $2}'`);	    
    $ciphertext_dec = base64_decode($lkey);
    $iv_dec = substr($ciphertext_dec, 0, $iv_size);
    $ciphertext_dec = substr($ciphertext_dec, $iv_size);
    $pl = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $key,$ciphertext_dec, MCRYPT_MODE_CBC, $iv_dec);
    $tarray = explode(',',$pl);
    if ($tarray[1] == $mac) {
		return $tarray[2];
	}
	return 0;
}    
	
public function removeLrCr(&$str) {
/*
 * remove any spurious lf/cr chars and multiple spaces
 */  
  $linefeeds   = array("\r\n", "\n", "\r");
  $str = str_replace($linefeeds, " ", $str); 
  $str = preg_replace('/\s+/', ' ', $str);
  return;
}

public function send404() {
	header('HTTP/1.0 404 Not Found');
	echo "Not Found (404)";
}  
                                              	
public function logIt($someText, $userloglevel=0) {
	$dbh = DB::getInstance();
	$res = $dbh->query("SELECT LOGLEVEL FROM globals where pkey = 'global'")->fetch(PDO::FETCH_ASSOC);
	$dbloglevel = $res['LOGLEVEL'];
	if ($userloglevel < $dbloglevel) {
		syslog(LOG_WARNING, date("M j H:i:s") . ": " . $someText . "\n");	
	}
}

public function checkCreds($pkey, $password, &$msg, $login) {
	
		$dbh = DB::getInstance();

        // retreive the user's information from the database using 
        // their username. 
        $query = "SELECT id,pkey,password,salt,email FROM user WHERE pkey = :pkey"; 
         
        // The parameter values 
        $query_params = array(  ':pkey' => $pkey );
        $pwd_ok = false;    
                  
        try 
        { 
            $stmt = $dbh->prepare($query); 
            $result = $stmt->execute($query_params); 
        } 
        catch(PDOException $ex) 
        { 
			$msg = "<B>Password check EXEC Error, $pkey</B>";
            return $pwd_ok;
        } 
        $row = $stmt->fetch(); 
        if($row) 
        { 
            // Using the password submitted by the user and the salt stored in the database, 
            // we now check to see whether the passwords match by hashing the submitted password 
            // and comparing it to the hashed version already stored in the database. 
            $check_password = hash('sha256', $password . $row['salt']); 
            for($round = 0; $round < 65536; $round++) 
            { 
                $check_password = hash('sha256', $check_password . $row['salt']); 
            } 
             
            if($check_password === $row['password']) 
            { 
                // If they do, then we flip this to true 
                $pwd_ok = true; 
            } 
        } 
         
        // If the user logged in successfully, then we send them to the private members-only page 
        // Otherwise, we display a login failed message and show the login form again 
        if($pwd_ok) { 
     		// if this is a login then store the user-info into the session (minus the salt and password)
            if ($login) { 
				unset($row['salt']); 
				unset($row['password']); 			
				$_SESSION['user'] = $row;
				$query = "UPDATE user SET lastlogin=datetime('now') WHERE pkey = :pkey";
				try { 
					$stmt = $dbh->prepare($query); 
					$result = $stmt->execute($query_params); 
					} 
				catch(PDOException $ex) 
				{ 
					$msg = "<B>Password check EXEC Error(TIME), $pkey</B>";
				}
			}
		// nag if password is factory default 
			$_SESSION['nag'] = false;
			if ($password == 'sarkadmin') {
				$_SESSION['nag'] = true;
			}
			return $pwd_ok; 
        } 
        // Tell the user they failed 
        $msg = "<B>Invalid credentials</B>";
        return $pwd_ok;
     
}


/**********************************************************************
 * Below here is a set of functions to build the default tuple(row) 
 * for each new insert.  Tuples are built as sparse arrays containing
 * only the columns which will be updated (and, of course, a key) and 
 * then passed to the general tuple setter
 *********************************************************************/ 
		
private function default_agent() {
	
	$rec = array(	
	"cluster"  	=> "default",
	"name"		=> "*NEW AGENT*",
	"queue1" 	=> "None",
	"queue2" 	=> "None",
	"queue3" 	=> "None",
	"queue4" 	=> "None",
	"queue5" 	=> "None",
	"queue6" 	=> "None"
     );
	 $this->setCluster($rec);
     return $rec;
}
				
private function default_appl() {
	
	$rec = array(
	"cluster" 	=> "default",
	"desc" => "new row",
	"span" => "Neither"
     );
     $this->setCluster($rec);
     return $rec;
}	

private function default_callback() {
	
	$rec = array(
	"cluster" 	=> "default",
     );	
     $this->setCluster($rec);
     return $rec;
}

private function default_clid_blacklist() {
	
	$rec = array(
	"cluster" 	=> "default",
     );	
     $this->setCluster($rec);
     return $rec;
}

private function default_cluster() {
	
	$rec = array(
	"abstimeout" 	=> "14400",
	"chanmax"		=> "3"
     );	
     return $rec;
}

private function default_cos() {
	
	$rec = array(
	"active" 		=> "YES", 		
	"dialplan"		=> null, 	
	"defaultopen" 	=> "NO",
	"defaultclosed" => "NO",
	"orideopen" 	=> "NO",
	"orideclosed" 	=> "NO"
	);	
	 
     return $rec;
}

private function default_dateSeg() {
	
	$rec = array(
        "cluster"	=> "default",
        "datemonth"	=> "*",
        "dayofweek"	=> "*",
        "desc"		=> "*NEW RULE*",
        "month"		=> "*",
        "timespan"	=> "*"        
     );
     $this->setCluster($rec);	
     return $rec;
}

private function default_device() {
	
	$rec = array(
		"blfkeys" => "0",	
	);	
     return $rec;
}

private function default_greeting() {
	
	$rec = array(
	"cluster" 	=> "default",
     );	
     $this->setCluster($rec);
     return $rec;
}

private function default_holiday() {
	
	$rec = array(
	"cluster" 	=> "default",
	"route" 	=> "Operator",
	"routeclass" => 100,
     );	
     $this->setCluster($rec);
     return $rec;
}

private function default_ipphone() {
	
	$rec = array(
	"active" => "YES",
	"devicerec" 	=> "default",
	"cluster"  	=> "default",
	"sndcreds" => "Always"
     );	
     $this->setCluster($rec);
     return $rec;
}

private function default_IPphoneCOSclosed() {
	
	$rec = array();	
     return $rec;
}

private function default_IPphoneCOSopen() {
	
	$rec = array();	
     return $rec;
}	

private function default_ivrmenu() {
	
	$rec = array(
	"cluster"  			=> "default", 
    "greetnum"  		=> null,
    "option0"			=> "None",
    "option1"			=> "None",
    "option2"			=> "None",
    "option3"			=> "None",
    "option4"			=> "None",
    "option5"			=> "None",
    "option6"			=> "None",
    "option7"			=> "None",
    "option8"			=> "None",
    "option9"			=> "None",
    "option10" 			=> "None",
    "option11" 			=> "None",
    "routeclass0"		=> 0,
    "routeclass1"		=> 0,
    "routeclass2"		=> 0,
    "routeclass3"		=> 0,
    "routeclass4"		=> 0,
    "routeclass5"		=> 0,
    "routeclass6"		=> 0,
    "routeclass7"		=> 0,
    "routeclass8"		=> 0,
    "routeclass9"		=> 0,
    "routeclass10" 		=> 0,
    "routeclass11" 		=> 0,
	"timeout"			=> "Operator", 	
	"timeoutrouteclass" => "100",
	"listenforext"		=> "NO"
	);	
	$this->setCluster($rec);
	 
    return $rec;
}

private function default_lineio() {
	
	$rec = array(
	"pkey"	 		=> null,
    "active" 		=> "YES",
	"callprogress"  => "NO",
	"closeroute" 	=> "Operator",
	"cluster" 		=> "default",
	"faxdetect"		=> "NO",
	"lcl" 			=> "NO",
	"moh" 			=> "NO",
	"monitor" 		=> "NO",
	"openroute" 	=> "Operator",
	"routeable" 	=> "NO",
    "routeclassopen" => 100,
    "routeclassclosed" => 100,
	"swoclip" 		=> "YES"
     );	
     $this->setCluster($rec);
     return $rec;
}

private function default_queue() {
	
	$conf = "musiconhold=default";
	$conf .= "\nstrategy=ringall";
	$conf .= "\ntimeout=300";
	$conf .= "\nretry=5";
	$conf .= "\nwrapuptime=0";
	$conf .= "\nmaxlen=0";
	$conf .= "\nannounce-frequency=30";
	$conf .= "\nannounce-holdtime=yes";
		
	$rec = array(
        "cluster"	=> "default",
        "devicerec"	=> "None",
        "options"	=> "t",
        "conf"		=> $conf
     );	
     $this->setCluster($rec);
     return $rec;
}

private function default_shorewall_blacklist() {
	 $rec = array();	
     return $rec;
}

private function default_route() {
	
	$rec = array(
		"active"	=> "YES",
		"auth"		=> "NO",		
        "cluster"	=> "default",
        "desc"  	=> "*NEW ROUTE*",
        "dialplan"  => "_XXXXXX.",
        "path1"		=> "None",
        "path2"		=> "None",
        "path3"		=> "None",
        "path4"		=> "None",
        "strategy"  => "hunt"      
     );	
     $this->setCluster($rec);
     return $rec;
}

private function default_speed() {
	
	$rec = array(
        "cluster"				=> "default",
        "dialparamsring" 		=> "ciIkt",
        "dialparamshunt" 		=> "cIkt",
        "outcomerouteclass"    	=> 100,
        "ringdelay"    			=> "15"
     );	
     $this->setCluster($rec);
     return $rec;
}

private function default_user() {
	
	$rec = array(
		"cluster"	=> "default",
	);	
    return $rec;
    $this->setCluster($rec); 
}

private function default_mcast() {
	
	$rec = array(
		"mcastip" => "224.0.1.75",
		"mcasttype"	=> "Dial"
	);	
    return $rec;
    $this->setCluster($rec); 
}

private function default_meetme() {
	
	$rec = array(
		"cluster" => "default",
		"type"	=> "simple",
		"adminpin" => "",
		"pin" => ""
	);	
    return $rec;
    $this->setCluster($rec); 
}

private function country_codes($search,$vector=true) {

$countries = array(  'AF'=>'AFGHANISTAN', 
					 'AL'=>'ALBANIA', 
					 'DZ'=>'ALGERIA', 
					 'AS'=>'AMERICAN SAMOA', 
					 'AD'=>'ANDORRA', 
					 'AO'=>'ANGOLA', 
					 'AI'=>'ANGUILLA', 
					 'AQ'=>'ANTARCTICA', 
					 'AG'=>'ANTIGUA AND BARBUDA', 
					 'AR'=>'ARGENTINA', 
					 'AM'=>'ARMENIA', 
					 'AW'=>'ARUBA', 
					 'AU'=>'AUSTRALIA', 
					 'AT'=>'AUSTRIA', 
					 'AZ'=>'AZERBAIJAN', 
					 'BS'=>'BAHAMAS', 
					 'BH'=>'BAHRAIN', 
					 'BD'=>'BANGLADESH', 
					 'BB'=>'BARBADOS', 
					 'BY'=>'BELARUS', 
					 'BE'=>'BELGIUM', 
					 'BZ'=>'BELIZE', 
					 'BJ'=>'BENIN', 
					 'BM'=>'BERMUDA', 
					 'BT'=>'BHUTAN', 
					 'BO'=>'BOLIVIA', 
					 'BA'=>'BOSNIA AND HERZEGOVINA', 
					 'BW'=>'BOTSWANA', 
					 'BV'=>'BOUVET ISLAND', 
					 'BR'=>'BRAZIL', 
					 'IO'=>'BRITISH INDIAN OCEAN TERRITORY', 
					 'BN'=>'BRUNEI DARUSSALAM', 
					 'BG'=>'BULGARIA', 
					 'BF'=>'BURKINA FASO', 
					 'BI'=>'BURUNDI', 
					 'KH'=>'CAMBODIA', 
					 'CM'=>'CAMEROON', 
					 'CA'=>'CANADA', 
					 'CV'=>'CAPE VERDE', 
					 'KY'=>'CAYMAN ISLANDS', 
					 'CF'=>'CENTRAL AFRICAN REPUBLIC', 
					 'TD'=>'CHAD', 
					 'CL'=>'CHILE', 
					 'CN'=>'CHINA', 
					 'CX'=>'CHRISTMAS ISLAND', 
					 'CC'=>'COCOS (KEELING) ISLANDS', 
					 'CO'=>'COLOMBIA', 
					 'KM'=>'COMOROS', 
					 'CG'=>'CONGO', 
					 'CD'=>'CONGO, THE DEMOCRATIC REPUBLIC OF THE',
					 'CK'=>'COOK ISLANDS', 
					 'CR'=>'COSTA RICA', 
					 'CI'=>'COTE D IVOIRE', 
					 'HR'=>'CROATIA', 
					 'CU'=>'CUBA', 
					 'CY'=>'CYPRUS', 
					 'CZ'=>'CZECH REPUBLIC', 
					 'DK'=>'DENMARK', 
					 'DJ'=>'DJIBOUTI', 
					 'DM'=>'DOMINICA', 
					 'DO'=>'DOMINICAN REPUBLIC', 
					 'TP'=>'EAST TIMOR', 
					 'EC'=>'ECUADOR', 
					 'EG'=>'EGYPT', 
					 'SV'=>'EL SALVADOR', 
					 'GQ'=>'EQUATORIAL GUINEA', 
					 'ER'=>'ERITREA', 
					 'EE'=>'ESTONIA', 
					 'ET'=>'ETHIOPIA', 
					 'FK'=>'FALKLAND ISLANDS (MALVINAS)', 
					 'FO'=>'FAROE ISLANDS', 
					 'FJ'=>'FIJI', 
					 'FI'=>'FINLAND', 
					 'FR'=>'FRANCE', 
					 'GF'=>'FRENCH GUIANA', 
					 'PF'=>'FRENCH POLYNESIA', 
					 'TF'=>'FRENCH SOUTHERN TERRITORIES', 
					 'GA'=>'GABON', 
					 'GM'=>'GAMBIA', 
					 'GE'=>'GEORGIA',
					 'DE'=>'GERMANY', 
					 'GH'=>'GHANA', 
					 'GI'=>'GIBRALTAR', 
					 'GR'=>'GREECE', 
					 'GL'=>'GREENLAND', 
					 'GD'=>'GRENADA', 
					 'GP'=>'GUADELOUPE', 
					 'GU'=>'GUAM', 
					 'GT'=>'GUATEMALA', 
					 'GN'=>'GUINEA', 
					 'GW'=>'GUINEA-BISSAU',
					 'GY'=>'GUYANA', 
					 'HT'=>'HAITI', 
					 'HM'=>'HEARD ISLAND AND MCDONALD ISLANDS', 
					 'VA'=>'HOLY SEE (VATICAN CITY STATE)', 
					 'HN'=>'HONDURAS', 
					 'HK'=>'HONG KONG', 
					 'HU'=>'HUNGARY', 
					 'IS'=>'ICELAND', 
					 'IN'=>'INDIA', 
					 'ID'=>'INDONESIA', 
					 'IR'=>'IRAN, ISLAMIC REPUBLIC OF', 
					 'IQ'=>'IRAQ', 'IE'=>'IRELAND', 
					 'IL'=>'ISRAEL', 
					 'IT'=>'ITALY', 
					 'JM'=>'JAMAICA', 
					 'JP'=>'JAPAN', 
					 'JO'=>'JORDAN', 
					 'KZ'=>'KAZAKSTAN', 
					 'KE'=>'KENYA', 
					 'KI'=>'KIRIBATI', 
					 'KP'=>'KOREA DEMOCRATIC PEOPLES REPUBLIC OF', 
					 'KR'=>'KOREA REPUBLIC OF', 
					 'KW'=>'KUWAIT', 
					 'KG'=>'KYRGYZSTAN', 
					 'LA'=>'LAO PEOPLES DEMOCRATIC REPUBLIC', 
					 'LV'=>'LATVIA', 
					 'LB'=>'LEBANON', 
					 'LS'=>'LESOTHO', 
					 'LR'=>'LIBERIA', 
					 'LY'=>'LIBYAN ARAB JAMAHIRIYA', 
					 'LI'=>'LIECHTENSTEIN', 
					 'LT'=>'LITHUANIA', 
					 'LU'=>'LUXEMBOURG', 
					 'MO'=>'MACAU', 
					 'MK'=>'MACEDONIA, THE FORMER YUGOSLAV REPUBLIC OF', 
					 'MG'=>'MADAGASCAR', 
					 'MW'=>'MALAWI', 
					 'MY'=>'MALAYSIA', 
					 'MV'=>'MALDIVES', 
					 'ML'=>'MALI', 
					 'MT'=>'MALTA', 
					 'MH'=>'MARSHALL ISLANDS', 
					 'MQ'=>'MARTINIQUE', 
					 'MR'=>'MAURITANIA', 
					 'MU'=>'MAURITIUS', 
					 'YT'=>'MAYOTTE', 
					 'MX'=>'MEXICO', 
					 'FM'=>'MICRONESIA, FEDERATED STATES OF', 
					 'MD'=>'MOLDOVA, REPUBLIC OF', 
					 'MC'=>'MONACO', 
					 'MN'=>'MONGOLIA', 
					 'MS'=>'MONTSERRAT', 
					 'MA'=>'MOROCCO', 
					 'MZ'=>'MOZAMBIQUE', 
					 'MM'=>'MYANMAR', 
					 'NA'=>'NAMIBIA', 
					 'NR'=>'NAURU', 
					 'NP'=>'NEPAL', 
					 'NL'=>'NETHERLANDS', 
					 'AN'=>'NETHERLANDS ANTILLES', 
					 'NC'=>'NEW CALEDONIA', 
					 'NZ'=>'NEW ZEALAND', 
					 'NI'=>'NICARAGUA', 
					 'NE'=>'NIGER', 
					 'NG'=>'NIGERIA', 
					 'NU'=>'NIUE', 
					 'NF'=>'NORFOLK ISLAND', 
					 'MP'=>'NORTHERN MARIANA ISLANDS', 
					 'NO'=>'NORWAY', 
					 'OM'=>'OMAN', 
					 'PK'=>'PAKISTAN', 
					 'PW'=>'PALAU', 
					 'PS'=>'PALESTINIAN TERRITORY, OCCUPIED', 
					 'PA'=>'PANAMA', 
					 'PG'=>'PAPUA NEW GUINEA', 
					 'PY'=>'PARAGUAY', 
					 'PE'=>'PERU', 
					 'PH'=>'PHILIPPINES', 
					 'PN'=>'PITCAIRN', 
					 'PL'=>'POLAND',
					 'PT'=>'PORTUGAL', 
					 'PR'=>'PUERTO RICO', 
					 'QA'=>'QATAR', 
					 'RE'=>'REUNION', 
					 'RO'=>'ROMANIA', 
					 'RU'=>'RUSSIAN FEDERATION', 
					 'RW'=>'RWANDA', 
					 'SH'=>'SAINT HELENA', 
					 'KN'=>'SAINT KITTS AND NEVIS', 
					 'LC'=>'SAINT LUCIA', 
					 'PM'=>'SAINT PIERRE AND MIQUELON', 
					 'VC'=>'SAINT VINCENT AND THE GRENADINES', 
					 'WS'=>'SAMOA', 
					 'SM'=>'SAN MARINO', 
					 'ST'=>'SAO TOME AND PRINCIPE', 
					 'SA'=>'SAUDI ARABIA', 
					 'SN'=>'SENEGAL', 
					 'SC'=>'SEYCHELLES', 
					 'SL'=>'SIERRA LEONE', 
					 'SG'=>'SINGAPORE', 
					 'SK'=>'SLOVAKIA', 
					 'SI'=>'SLOVENIA', 
					 'SB'=>'SOLOMON ISLANDS', 
					 'SO'=>'SOMALIA', 
					 'ZA'=>'SOUTH AFRICA', 
					 'GS'=>'SOUTH GEORGIA AND THE SOUTH SANDWICH ISLANDS', 
					 'ES'=>'SPAIN', 
					 'LK'=>'SRI LANKA', 
					 'SD'=>'SUDAN', 
					 'SR'=>'SURINAME', 
					 'SJ'=>'SVALBARD AND JAN MAYEN', 
					 'SZ'=>'SWAZILAND', 
					 'SE'=>'SWEDEN', 
					 'CH'=>'SWITZERLAND', 
					 'SY'=>'SYRIAN ARAB REPUBLIC', 
					 'TW'=>'TAIWAN, PROVINCE OF CHINA', 
					 'TJ'=>'TAJIKISTAN', 
					 'TZ'=>'TANZANIA, UNITED REPUBLIC OF', 
					 'TH'=>'THAILAND', 
					 'TG'=>'TOGO', 
					 'TK'=>'TOKELAU', 
					 'TO'=>'TONGA', 
					 'TT'=>'TRINIDAD AND TOBAGO', 
					 'TN'=>'TUNISIA', 
					 'TR'=>'TURKEY', 
					 'TM'=>'TURKMENISTAN', 
					 'TC'=>'TURKS AND CAICOS ISLANDS', 
					 'TV'=>'TUVALU', 
					 'UG'=>'UGANDA', 
					 'UA'=>'UKRAINE', 
					 'AE'=>'UNITED ARAB EMIRATES', 
					 'GB'=>'UNITED KINGDOM', 
					 'US'=>'UNITED STATES', 
					 'UM'=>'UNITED STATES MINOR OUTLYING ISLANDS', 
					 'UY'=>'URUGUAY', 
					 'UZ'=>'UZBEKISTAN', 
					 'VU'=>'VANUATU', 
					 'VE'=>'VENEZUELA', 
					 'VN'=>'VIET NAM', 
					 'VG'=>'VIRGIN ISLANDS, BRITISH', 
					 'VI'=>'VIRGIN ISLANDS, U.S.', 
					 'WF'=>'WALLIS AND FUTUNA', 
					 'EH'=>'WESTERN SAHARA', 
					 'YE'=>'YEMEN', 
					 'YU'=>'YUGOSLAVIA', 
					 'ZM'=>'ZAMBIA', 
					 'ZW'=>'ZIMBABWE' );
					
}
  
}
